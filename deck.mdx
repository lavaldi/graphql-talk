import { Head } from 'mdx-deck'
import { Image } from 'mdx-deck'
import { Appear } from 'mdx-deck'
export { default as theme } from './theme'
import { CodeSurfer } from 'mdx-deck-code-surfer'

<Head>
  <link rel="shortcut icon" href="./public/favicon.png" type="image/png" />
  <title>GraphQL Talk - La Valdi</title>
</Head>

![GraphQL logo](./public/logo.svg)
# GraphQL

---

## 驴Qu茅 es GraphQL?

```notes
Es un lenguaje de consulta de c贸digo abierto creado por Facebook
```

---

<CodeSurfer
  code={require("!raw-loader!./examples/init.txt")}
  lang="graphql"
  steps={[
    { notes: ""},
    { lines: [2,6], notes: "Fields" },
    { lines: [7,8], notes: "Nested fields" }
  ]}
/>

```notes
 Una QUERY puede solicitar m煤ltiples recursos (author, article), llamados FIELDS en GraphQL, y s贸lo un conjunto particular de campos anidados para estos campos (name, urlSlug para article), aunque la entidad misma puede ofrecer m谩s datos en su esquema GraphQL (por ejemplo, description, releaseData para el article).
 Una arquitectura RESTful necesita al menos dos peticiones en cascada para recuperar la entidad de autor y sus art铆culos, pero con GraphQL lo hemos hecho en una. Adem谩s, la s贸lo seleccionamos los campos necesarios en lugar de toda la entidad.
```

---

隆Eso es GraphQL! La aplicaci贸n servidor ofrece un esquema GraphQL, donde se definen todos los datos disponibles con su jerarqu铆a y tipos, y una aplicaci贸n cliente **s贸lo** consulta los datos requeridos.

---

## Ventajas 

---

- Obtenci贸n de datos declarativos.

```notes
 El cliente solicita en una sola consulta un conjunto de datos a obtener. Estos pueden ser de una sola entidad o de relaciones entre entidades.
```

---

<CodeSurfer
  code={require("!raw-loader!./examples/declarative-data.txt")}
  lang="graphql"
/>

---

- No hay sobrecarga de datos.

```notes
 Un cliente m贸vil suele sobrecargar datos cuando hay una API id茅ntica a la del cliente web con una API REST. Con GraphQL, el cliente m贸vil puede elegir un conjunto diferente de campos, por lo que s贸lo puede obtener la informaci贸n necesaria para lo que est谩 en pantalla.
```

---

- GraphQL para React, Angular, Node, etc.

```notes
 GraphQL est谩 desacoplado de cualquier soluci贸n de frontend o backend. La implementaci贸n de referencia de GraphQL est谩 escrita en JavaScript, por lo que se puede usar GraphQL en cualquier framework o librer铆a del lado del cliente y del servidor.
```

---

- Una sola fuente de verdad

```notes
 El esquema GraphQL es la 煤nica fuente de verdad en las aplicaciones GraphQL, ya que es donde se describen todos los datos disponibles. Las queries y los mutation se realizan basados en el esquema que ofrece la aplicaci贸n del lado del servidor.
```

---

<Image src='./public/schema-gateway.png' />

---

- Adopta las tendencias modernas

```notes
 Es posible que s贸lo tenga una aplicaci贸n back-end, pero varios clientes en la web, tel茅fonos y smartwatches, dependiendo de sus datos. GraphQL puede cumplir con los requisitos de cada aplicaci贸n del cliente - red, relaciones anidadas de datos, obtenci贸n de s贸lo los datos requeridos - sin una API dedicada para cada cliente. En el lado del servidor, puede haber un backend, pero tambi茅n un grupo de microservicios que ofrecen sus funcionalidades espec铆ficas.
```

---

- Uni贸n de Esquemas

---

- Introspecci贸n

```notes
 Dado que el esquema tiene toda la informaci贸n sobre los datos disponibles a trav茅s de la API de GraphQL, es perfecto para autogenerar la documentaci贸n de la API.
```

---

- Fuertemente tipado

---

<CodeSurfer
  code={`
  type References {
    id: Int!
    experienceId: Int!
    experienceJob: String!
    name: String
    primaryCellphone: String!
    secondaryCellphone: String
    email: String!
    job: String!
    company: String!
  }
  `}
  lang="graphql"
/>

---

- Versionado

```notes
 En GraphQL no hay versionado como en una API REST, lo que se hace es deprecar un campo y les llega la notificaci贸n a los clientes de que el campo est谩 deprecado. Despu茅s de un tiempo, el campo obsoleto puede eliminarse del esquema cuando ya no lo utilizan muchos clinetes. Esto hace posible evolucionar una API GraphQL a lo largo del tiempo sin necesidad de versionar.
```

---

## Desventajas 

---

- Complejidad de la consulta

```notes
 GraphQL no es un reemplazo para las bases de datos del lado del servidor, s贸lo es un lenguaje de consulta. Es decir que una query necesita ser resuelta con datos en el servidor (ej. base de datos).
 Adem谩s, GraphQL no elimina los cuellos de botella de rendimiento cuando tiene que acceder a m煤ltiples campos (autores, art铆culos, comentarios) en una consulta, porque todav铆a tienen que ser recuperados de una fuente de datos.
锔 Hay que tener cuidado cuando se solicita demasiados campos anidados a la vez. Debe haber un mecanismo como la profundidad m谩xima de las consultas, checar la complejidad de las consultas, evitar la recursi贸n, o las consultas persistentes para detener las solicitudes ineficientes del lado del servidor.
```

---

- Limitaci贸n de la velocidad

```notes
 Mientras que en REST es m谩s sencillo decir "s贸lo permitimos un n煤mero limitado de peticiones de recursos en un d铆a", resulta dif铆cil hacer una declaraci贸n de este tipo para operaciones individuales de GraphQL, ya que puede ser todo entre una operaci贸n barata y una operaci贸n costosa.
```

---

- Almacenamiento en cach茅

```notes
 Con GraphQL es m谩s complejo que implementar una cach茅 en REST. Ya que en REST, se accede a los recursos con URLs, por lo que se puede cachear porque se tiene la URL del recurso como identificador. En GraphQL, esto se vuelve complejo porque cada consulta puede ser diferente, aunque opere en la misma entidad.

Ej. S贸lo puede solicitar el nombre de un autor en una consulta, pero en la siguiente se quiere saber la direcci贸n de correo electr贸nico. Ah铆 es donde se necesita una cach茅 de grano m谩s fino a nivel de campo, que puede ser dif铆cil de implementar. Sin embargo, la mayor铆a de las librer铆as construidas sobre GraphQL ofrecen mecanismos de cacheo.
```

---

## 驴Por qu茅 no REST? 

---

<ul>
  <Appear>
    <li>Una URL para cada recurso</li>
    <li>Puede generar solicitudes de cascada ineficientes</li>
    <li>El cliente no decide sobre los datos</li>
  </Appear>
</ul>

```notes
 Por ejemplo, imagina que quieres obtener una entidad de autor identificada por un id, y luego obtienes todos los art铆culos de este autor usando el id del autor. En GraphQL, esta es una 煤nica petici贸n, lo cual es m谩s eficiente. Si s贸lo desea obtener los art铆culos del autor sin la entidad de autor completa, GraphQL le permite seleccionar s贸lo las partes que necesita. En REST, se sobrecargar铆a a toda la entidad autora.
 Esta es la raz贸n principal por la que GraphQL fue inventado en primer lugar, porque el cliente m贸vil de Facebook requer铆a datos diferentes a los de su cliente web.
```

---

Gracias 
